---
title: "Resilience Model Uncertainty Analysis"
author: "Roy Emanuel II"
output:
    html_document
    # md_document:
        #variant: markdown_github
bibliography: mendeley.bib
---
# Resilience Models
## Quotient resilience and total quotient resilience
## Expected System Degradation Function (ESDF) and resilience factor
## Integral resilience
For simplicity we will start out with just the extended integral
resilience metric becaus I think this is the one that matters. We have
shown with the simple stories that they are not viable for these
situations. Trying to rebuild the situation from the
anyLogicDataPull.R file.
```{r}
uncScenFast <- function(data, simRun, need, resFactors, timeHorizon=NULL){
    resMat <- data.frame()
    needStep <- dim(need)[1]
    resStep <- dim(resFactors)[1]

}
```
# Uncertainty Communication

The focus of this section is to build the format for working through
the analysis of the uncertainty quantification of the different 
resilience metrics.
## Time to failure
The systems will typically be exposed to failure multiple times over
the time horizon. Consider this some sort of renewal process. This is
the important thing to consider here. 
### HPP
Simplest is the Homogeneous Poisson process (HPP). Actually, no, what
I want to do is use the exponential distribution, and sample from it
until the time runs out. 

scenarioBuild builds a data frame that produces failure and recovery
events that accumulate until the timehorizon is surpassed. These
are used by performance build to build a performance profile that
can fit into the resilience metric calculators
```{r}
library("plyr")
library("dplyr")
set.seed(8541984)
scenarioBuild <- function(lambda, timeHorizon, numScen){
    outDF <- data.frame()
    for(s in 1:numScen){
        DF <- data.frame()
        t <- 0
        while(t < timeHorizon){
            f <- ceiling(rexp(n = 1, lambda))
            fLev <- rbeta(n = 1, shape1 = 1, shape2 = 5)
            fDF <- data.frame(time = f,
                              event = "Fail",
                              scenario = s,
                              Level = fLev)
            DF <- bind_rows(DF, fDF)
            t <- t + f
            if(t > timeHorizon){break}
            r <- ceiling(rexp(n = 1, lambda))
            rLev <- rbeta(n = 1, shape1 = 5, shape2 = 1)
            rDF <- data.frame(time = r,
                              event = "Recover",
                              scenario = s,
                              Level = rLev)
            DF <- bind_rows(DF, rDF)
            t <- t + r
        }
        DF$cumFail <- cumsum(DF$time)
        outDF <- bind_rows(outDF, DF)
    }
    return(outDF)
}
```

performanceBuild takes the built scenarios and makes time-sereis
data that is ingested by the resilience calculators
```{r}
performanceBuild <- function(buildDF, timeHorizon, perfInit){
    allDF <- data.frame()
    for (s in 1:max(buildDF$scenario)){
        workDF <- filter(buildDF, scenario == s)
        p <- perfInit
        startTime <- 0
        scenDF <- data.frame()
        for(r in 1:nrow(workDF)){
            timeCol <- seq(from = startTime,
                           to = startTime + workDF$time[r] - 1,
                           by = 1)
            perfLevel <- rep(p, workDF$time[r])
            eventDF <- data.frame(Time = timeCol,
                                  Performance = perfLevel,
                                  Scenario = s)
            startTime <- startTime + workDF$time[r]
            p <- workDF$Level[r]
            scenDF <- bind_rows(scenDF, eventDF)
        }
        scenDF <- filter(scenDF, Time <= timeHorizon)
        outList <- c(func = "custom",
                        Performance = scenDF$Performance)
    }

    return(outList)
}

g <- scenarioBuild(1/10, 100, 3)
h <- performanceBuild(g, 100, 1)
print(head(g))
print(head(h, 50))
print(dim(h))
```

### NHPP
Next is the Nonhomogeneous Poisson process (NHPP)

### Renewal process
Finally is the general case of a renewal process.
## Robustness
Robustness can vary from the previous value to zero, so it must be a
bounded distribution of some type. Beta is probably a good
distribution for this one.

## Time to recover
Time to recover is similar to time to repair. In the literature (SHOW
THIS) a lognormal distribution can be a good value for it.
## Level of recovery
Level of recovery is like robustness, so again, a bounded equation,
but recovery may be greater than the previous value, so the upperbound
may be a distribution itself. Try to bound within reality.
## Stakeholder time horizon
Defined by the stakeholder.
## Stakeholder endogenous preference
Look into the prognostic and predictive work. how do economists
predict future demand?
## Stakeholder intertemporal substitutability
Look more seriously at the economic description of it and make it
apply to what we are doing today.
